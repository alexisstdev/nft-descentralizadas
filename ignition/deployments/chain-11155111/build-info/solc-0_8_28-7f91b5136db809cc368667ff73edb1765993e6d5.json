{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-7f91b5136db809cc368667ff73edb1765993e6d5",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Wallet.sol": "project/contracts/Wallet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Wallet.sol": {
        "content": "//SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.0;\n\ncontract MultiSignPaymentWallet {\n    address[] public owners;\n    uint public requiredApprovals;\n    mapping(address => bool) public isOwner;\n\n    struct Transaction {\n        address to;\n        uint amount;\n        uint approvalCount;\n        bool executed;\n    }\n\n    struct Approval {\n        address approver;\n        uint256 timestamp;\n    }\n\n    Transaction[] public transactions;\n    mapping(uint => mapping(address => bool)) public approvals;\n    mapping(uint => Approval[]) public transactionApprovals;\n    mapping(uint => mapping(address => uint256)) public approvalTimestamps;\n    //ContratoPagos\n    address[] public payees;\n    mapping(address => uint) public shares;\n    uint256 public totalShares;\n    //---------------\n    uint256 private _status;\n\n    modifier nonReentrant() {\n        require(_status != 2, \"Reentrancy Guard:Reentrant call\");\n        _status = 2;\n        _;\n        _status = 1;\n    }\n\n    event Deposit(address indexed sender, uint amount);\n\n    event TransactionSubmitted(\n        uint indexed txId,\n        address indexed to,\n        uint amount\n    );\n\n    event TransactionRevoked(uint indexed txId, address owner);\n\n    event TransactionApproved(uint indexed txId, address owner);\n\n    event TransactionExecuted(\n        uint indexed txId,\n        address indexed to,\n        uint amount\n    );\n\n    event PaymentReleased(address indexed payee, uint amount);\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender]);\n        _;\n    }\n\n    constructor(\n        address[] memory _owners,\n        uint _requiredApprovals,\n        address[] memory _payees,\n        uint256[] memory _shares\n    ) {\n        _status = 1;\n        require(_owners.length > 0, \"Must have owners\");\n        require(\n            _requiredApprovals > 0 && _requiredApprovals <= _owners.length,\n            \"Invalid Approvals\"\n        );\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"Invalid Address\");\n            require(!isOwner[owner], \"Owner not unique\");\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        requiredApprovals = _requiredApprovals;\n\n        //ContratoPagos\n        require(_payees.length == _shares.length, \"Length mismatch\");\n        require(_payees.length > 0, \"No payees\");\n        for (uint i = 0; i < _payees.length; i++) {\n            require(_payees[i] != address(0), \"invalid address\");\n            require(_shares[i] > 0, \"shares must be>0\");\n            payees.push(_payees[i]);\n            shares[_payees[i]] = _shares[i];\n            totalShares += _shares[i];\n        }\n    }\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Debes mandar ether\");\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function submitTransaction(address _to, uint amount) external onlyOwner {\n        require(_to != address(0), \"Invalid Address\");\n        require(amount > 0, \"Invalid Amount\");\n        require(amount <= address(this).balance, \"Insufficient balance\");\n        transactions.push(\n            Transaction({\n                to: _to,\n                amount: amount,\n                approvalCount: 0,\n                executed: false\n            })\n        );\n        emit TransactionSubmitted(transactions.length - 1, _to, amount);\n    }\n\n    function approveTransaction(uint txId) external onlyOwner {\n        require(txId < transactions.length, \"Invalid transaction ID\");\n        Transaction storage transaction = transactions[txId];\n        require(!transaction.executed, \"Tx already executed\");\n        require(!approvals[txId][msg.sender], \"Tx already approved by caller\");\n\n        approvals[txId][msg.sender] = true;\n        transaction.approvalCount += 1;\n\n        // Track approval with timestamp\n        transactionApprovals[txId].push(\n            Approval({approver: msg.sender, timestamp: block.timestamp})\n        );\n        approvalTimestamps[txId][msg.sender] = block.timestamp;\n\n        emit TransactionApproved(txId, msg.sender);\n    }\n\n    function revokeApproval(uint txId) external onlyOwner {\n        require(txId < transactions.length, \"Invalid transaction ID\");\n        Transaction storage transaction = transactions[txId];\n        require(!transaction.executed, \"Tx already executed\");\n        require(approvals[txId][msg.sender], \"Tx not approved by caller\");\n\n        approvals[txId][msg.sender] = false;\n        transaction.approvalCount -= 1;\n        emit TransactionRevoked(txId, msg.sender);\n    }\n\n    function executeTransaction(uint txId) external onlyOwner nonReentrant {\n        require(txId < transactions.length, \"Invalid transaction ID\");\n        Transaction storage transaction = transactions[txId];\n        require(\n            transaction.approvalCount >= requiredApprovals,\n            \"Not enough approvals\"\n        );\n        require(!transaction.executed, \"Tx already executed\");\n        require(\n            transaction.amount <= address(this).balance,\n            \"Insufficient balance\"\n        );\n        transaction.executed = true;\n        (bool success, ) = transaction.to.call{value: transaction.amount}(\"\");\n        require(success, \"Tx failed\");\n        emit TransactionExecuted(txId, transaction.to, transaction.amount);\n    }\n\n    function releasePayments() external nonReentrant {\n        uint256 contractBalance = address(this).balance;\n        require(contractBalance > 0, \"No funds to release\");\n        for (uint256 i = 0; i < payees.length; i++) {\n            address payee = payees[i];\n            uint256 payment = (contractBalance * shares[payee]) / totalShares;\n\n            if (payment > 0) {\n                (bool success, ) = payee.call{value: payment}(\"\");\n                require(success, \"Payment failed\");\n                emit PaymentReleased(payee, payment);\n            }\n        }\n    }\n\n    function getTransactions() external view returns (Transaction[] memory) {\n        return transactions;\n    }\n\n    function getTransactionApprovers(\n        uint txId\n    ) external view returns (Approval[] memory) {\n        require(txId < transactions.length, \"Invalid transaction ID\");\n        return transactionApprovals[txId];\n    }\n\n    function getBalance() external view returns (uint) {\n        return address(this).balance;\n    }\n}\n"
      }
    }
  }
}